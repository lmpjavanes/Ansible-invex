---
# roles/software_installer/tasks/process_linux_package.yml

- name: "Linux | Inicializar variables por paquete (evitar undefined)"
  ansible.builtin.set_fact:
    install_result:
      rc: "N/A"
      stdout: ""
      stderr: ""
    validation_result:
      rc: "N/A"
      stdout: ""
      stderr: ""
    _report_dir_effective: "{{ report_dir | default('/tmp') }}"

- name: "Linux | Procesando {{ pkg.name | default('paquete_sin_nombre') }}"
  vars:
    _pkg_name: "{{ pkg.name | default('') }}"
    _pkg_file: "{{ pkg.src_file | default('') }}"
    _pkg_desc: "{{ pkg.description | default('') }}"
    _pkg_vendor: "{{ pkg.vendor | default('') }}"
    _dest_path: "{{ pkg.dest_path | default('/tmp/') }}"
    source_full_path: "/software_repo/{{ _pkg_file }}"
    dest_full_path: "{{ _dest_path }}{{ _pkg_file }}"
    controller_temp_path: "/tmp/ansible_temp_{{ _pkg_file }}"

    _cmd_install_base: "{{ (pkg.commands.install | default('rpm -ivh')) | trim }}"
    _cmd_post_validate: "{{ (pkg.commands.post_install_validation | default('')) | trim }}"
    _cmd_activation: "{{ (pkg.commands.activation | default('')) | trim }}"
    _cmd_start: "{{ (pkg.commands.start | default('')) | trim }}"
    _cmd_status: "{{ (pkg.commands.status | default('')) | trim }}"

    _version_regex: "{{ pkg.version_regex | default('') }}"
  block:

    # ===========================
    # 0) Validaciones mínimas
    # ===========================
    - name: "Linux | Validar definición mínima del paquete"
      ansible.builtin.assert:
        that:
          - _pkg_name | length > 0
          - _pkg_file | length > 0
          - _cmd_post_validate | length > 0
        fail_msg: >-
          Definición incompleta del paquete. Se requiere: name, src_file,
          y commands.post_install_validation. Paquete recibido: {{ pkg | to_nice_json }}

    # ===========================
    # 1) Verificar en origen (invd-ts-ansible)
    # ===========================
    - name: "Linux | Verificar que el archivo existe en invd-ts-ansible"
      ansible.builtin.stat:
        path: "{{ source_full_path }}"
      delegate_to: invd-ts-ansible
      register: file_check
      run_once: true

    - name: "Linux | Detener si el archivo no existe"
      ansible.builtin.fail:
        msg: "El archivo {{ source_full_path }} no existe en invd-ts-ansible"
      when: not file_check.stat.exists

    # ===========================
    # 2) Fetch al controller
    # ===========================
    - name: "Linux | FETCH - Traer archivo desde invd-ts-ansible al nodo controlador"
      ansible.builtin.fetch:
        src: "{{ source_full_path }}"
        dest: "{{ controller_temp_path }}"
        flat: true
      delegate_to: invd-ts-ansible
      register: fetch_result
      run_once: true

    - name: "Linux | Verificar que el fetch fue exitoso (controller)"
      ansible.builtin.stat:
        path: "{{ controller_temp_path }}"
      delegate_to: localhost
      register: fetch_check
      run_once: true

    - name: "Linux | Detener si el archivo no se copió al controlador"
      ansible.builtin.fail:
        msg: "El archivo {{ controller_temp_path }} no existe en el nodo controlador"
      when: not fetch_check.stat.exists

    # ===========================
    # 3) Copiar al host destino
    # ===========================
    - name: "Linux | Copiar archivo desde nodo controlador al servidor destino"
      ansible.builtin.copy:
        src: "{{ controller_temp_path }}"
        dest: "{{ dest_full_path }}"
        mode: "0644"
      register: copy_result

    - name: "Linux | Verificar que el archivo se copió al destino"
      ansible.builtin.stat:
        path: "{{ dest_full_path }}"
      register: copy_check

    - name: "Linux | Detener si el archivo no se copió al destino"
      ansible.builtin.fail:
        msg: "El archivo {{ dest_full_path }} no existe en el host destino"
      when: not copy_check.stat.exists

    # ===========================
    # 4) Pre-validación: ¿ya está instalado?
    # ===========================
    - name: "Linux | Pre-validación usando post_install_validation"
      ansible.builtin.shell: |
        set -o pipefail
        {{ _cmd_post_validate }}
      args:
        executable: /bin/bash
      register: pre_validation
      changed_when: false
      failed_when: false

    - name: "Linux | Determinar si el paquete ya está instalado"
      ansible.builtin.set_fact:
        package_installed: "{{ (pre_validation.rc | default(1)) == 0 }}"

    # ===========================
    # 5) Instalación (solo si NO está instalado)
    # ===========================
    - name: "Linux | Instalar paquete (si no está instalado)"
      ansible.builtin.shell: |
        set -o pipefail
        {{ _cmd_install_base }} "{{ dest_full_path }}"
      args:
        executable: /bin/bash
      register: install_result
      when: not package_installed
      failed_when: false

    # ===========================
    # 6) Post-validación
    # ===========================
    - name: "Linux | Post-validación usando post_install_validation"
      ansible.builtin.shell: |
        set -o pipefail
        {{ _cmd_post_validate }}
      args:
        executable: /bin/bash
      register: post_validation
      changed_when: false
      failed_when: false

    - name: "Linux | Construir validation_result"
      ansible.builtin.set_fact:
        validation_result:
          rc: "{{ post_validation.rc | default(1) }}"
          stdout: "{{ post_validation.stdout | default('') }}"
          stderr: "{{ post_validation.stderr | default('') }}"

    - name: "Linux | Determinar si el paquete quedó instalado después"
      ansible.builtin.set_fact:
        package_installed_after: "{{ (post_validation.rc | default(1)) == 0 }}"

    # ===========================
    # 6.1) Obtener versión (si hay version_regex)
    # ===========================
    - name: "Linux | Calcular versión instalada (desde stdout de validación)"
      ansible.builtin.set_fact:
        version_installed: >-
          {{
            (
              (validation_result.stdout | default(''))
              | regex_search(_version_regex, '\\1')
            ) if (_version_regex | length > 0) else ''
          }}

    # ===========================
    # 6.2) Obtener fecha de instalación (mejor esfuerzo)
    # ===========================
    - name: "Linux | Obtener fecha de instalación (rpm -qi) (best-effort)"
      ansible.builtin.shell: |
        set -o pipefail
        rpm -qi "{{ _pkg_name }}" | awk -F': ' '/Install Date/ {print $2; exit 0}'
      args:
        executable: /bin/bash
      register: install_date_cmd
      changed_when: false
      failed_when: false
      when: package_installed_after | bool

    - name: "Linux | Set install_date (best-effort)"
      ansible.builtin.set_fact:
        install_date: "{{ (install_date_cmd.stdout | default('')) | trim }}"
      when: package_installed_after | bool

    - name: "Linux | Set install_date default"
      ansible.builtin.set_fact:
        install_date: ""
      when: install_date is not defined

    # ===========================
    # 7) (Opcional) Activation / Start / Status (SentinelAgent futuro)
    # ===========================
    - name: "Linux | Ejecutar activación (opcional)"
      ansible.builtin.shell: |
        set -o pipefail
        {{ _cmd_activation }}
      args:
        executable: /bin/bash
      register: activation_result
      when:
        - package_installed_after | bool
        - _cmd_activation | length > 0
      changed_when: false
      failed_when: false

    - name: "Linux | Iniciar servicio/agente (opcional)"
      ansible.builtin.shell: |
        set -o pipefail
        {{ _cmd_start }}
      args:
        executable: /bin/bash
      register: start_result
      when:
        - package_installed_after | bool
        - _cmd_start | length > 0
      changed_when: false
      failed_when: false

    - name: "Linux | Verificar status (opcional)"
      ansible.builtin.shell: |
        set -o pipefail
        {{ _cmd_status }}
      args:
        executable: /bin/bash
      register: status_result
      when:
        - package_installed_after | bool
        - _cmd_status | length > 0
      changed_when: false
      failed_when: false

    # ===========================
    # 8) Construir resultado de este paquete y APPEND a host_installation_results
    # ===========================
    - name: "Linux | Construir status final del paquete"
      ansible.builtin.set_fact:
        _pkg_status: "{{ 'success' if (package_installed_after | bool) else 'failed' }}"

    - name: "Linux | Construir mensaje de paquete (para reportes)"
      ansible.builtin.set_fact:
        _pkg_message: >-
          {% if package_installed | bool %}
          Paquete instalado previamente
          {% elif package_installed_after | bool %}
          Paquete instalado correctamente
          {% else %}
          Falló instalación/validación
          {% endif %}

    - name: "Linux | Agregar resultado del paquete a host_installation_results"
      ansible.builtin.set_fact:
        host_installation_results: >-
          {{
            (host_installation_results | default([])) + [
              {
                'package_name': _pkg_name,
                'description': _pkg_desc,
                'vendor': _pkg_vendor,
                'status': _pkg_status,
                'ya_instalado': (package_installed | default(false)),
                'install_date': (install_date | default('')),
                'version_installed': (version_installed | default('')),
                'message': _pkg_message
              }
            ]
          }}

    # ===========================
    # 9) Limpieza (opcional)
    # ===========================
    - name: "Linux | Eliminar archivo copiado en destino (opcional)"
      ansible.builtin.file:
        path: "{{ dest_full_path }}"
        state: absent
      when: (pkg.cleanup_dest | default(false)) | bool

    - name: "Linux | Eliminar archivo temporal en controlador"
      ansible.builtin.file:
        path: "{{ controller_temp_path }}"
        state: absent
      delegate_to: localhost
      run_once: true

    # ===========================
    # 10) Log por host (best-effort)
    # ===========================
    - name: "Linux | Guardar verificación en archivo de log"
      ansible.builtin.copy:
        dest: "{{ _report_dir_effective }}/linux_software_install_{{ inventory_hostname }}.log"
        content: |
          ============================================
          Host: {{ inventory_hostname }}
          Paquete: {{ _pkg_name }}
          Archivo: {{ _pkg_file }}
          Fecha: {{ ansible_date_time.iso8601 }}
          --------------------------------------------
          post_install_validation: {{ _cmd_post_validate }}
          Instalado (antes): {{ package_installed | default('N/A') }}
          RC pre-validación: {{ pre_validation.rc | default('N/A') }}
          OUT pre-validación: {{ pre_validation.stdout | default('') }}
          ERR pre-validación: {{ pre_validation.stderr | default('') }}
          --------------------------------------------
          Instalación ejecutada: {{ (not package_installed) | default(false) }}
          Código instalación: {{ install_result.rc | default('N/A') }}
          OUT instalación: {{ install_result.stdout | default('') }}
          ERR instalación: {{ install_result.stderr | default('') }}
          --------------------------------------------
          Instalado (después): {{ package_installed_after | default('N/A') }}
          RC post-validación: {{ validation_result.rc | default('N/A') }}
          OUT post-validación: {{ validation_result.stdout | default('') }}
          ERR post-validación: {{ validation_result.stderr | default('') }}
          --------------------------------------------
          Versión instalada: {{ version_installed | default('') }}
          Fecha instalación: {{ install_date | default('') }}
          ============================================

  rescue:
    - name: "Linux | Error al procesar {{ pkg.name | default('paquete_sin_nombre') }}"
      ansible.builtin.debug:
        msg:
          - "Ocurrió un error al procesar el paquete {{ pkg.name | default('N/A') }}"
          - "Error: {{ ansible_failed_result | default({}) }}"

    # Aun con error, agregamos un registro para que el reporte muestre el paquete y el fallo
    - name: "Linux | Agregar resultado fallido del paquete a host_installation_results (para reporte)"
      ansible.builtin.set_fact:
        host_installation_results: >-
          {{
            (host_installation_results | default([])) + [
              {
                'package_name': (pkg.name | default('N/A')),
                'description': (pkg.description | default('')),
                'vendor': (pkg.vendor | default('')),
                'status': 'failed',
                'ya_instalado': false,
                'install_date': '',
                'version_installed': '',
                'message': 'Falló instalación/validación'
              }
            ]
          }}

    - name: "Linux | Guardar error en log (fallback seguro)"
      ansible.builtin.copy:
        dest: "{{ _report_dir_effective }}/linux_software_install_{{ inventory_hostname }}.log"
        content: |
          ============================================
          Host: {{ inventory_hostname }}
          Paquete: {{ pkg.name | default('N/A') }}
          Archivo: {{ pkg.src_file | default('N/A') }}
          Fecha: {{ ansible_date_time.iso8601 }}
          --------------------------------------------
          ERROR durante el procesamiento del paquete.
          Detalle:
          {{ ansible_failed_result | default({}) }}
          ============================================

  always:
    - name: "Linux | Fin del procesamiento de {{ pkg.name | default('paquete_sin_nombre') }}"
      ansible.builtin.debug:
        msg: "Finalizó procesamiento de {{ pkg.name | default('N/A') }} en {{ inventory_hostname }}"
