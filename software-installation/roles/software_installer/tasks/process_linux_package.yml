---
# roles/software_installer/tasks/process_linux_package.yml

- name: "Linux | Procesando {{ pkg.name }}"
  vars:
    # Ruta del archivo fuente en invd-ts-ansible
    source_full_path: "/software_repo/{{ pkg.src_file }}"
    # Ruta destino en el servidor Linux
    dest_full_path: "{{ pkg.dest_path | default('/tmp/') }}{{ pkg.src_file }}"
    # IP de invd-ts-ansible (hardcodeada o desde variable)
    source_server: "192.168.56.13"
  block:
    - name: "Linux | Verificar que el archivo existe en invd-ts-ansible"
      ansible.builtin.stat:
        path: "{{ source_full_path }}"
      delegate_to: invd-ts-ansible
      register: file_check
      run_once: true

    - name: "Linux | Detener si el archivo no existe"
      ansible.builtin.fail:
        msg: "El archivo {{ source_full_path }} no existe en invd-ts-ansible"
      when: not file_check.stat.exists

    - name: "Linux | COPIAR ARCHIVO USANDO SCP CON TIMEOUT"
      ansible.builtin.shell: |
        set -x
        echo "=== INICIANDO COPIA CON SCP ==="
        echo "Origen: {{ source_server }}:{{ source_full_path }}"
        echo "Destino: {{ dest_full_path }}"
        
        # Verificar conectividad primero (con timeout)
        timeout 5 ping -c 1 {{ source_server }} > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "❌ No hay conectividad con {{ source_server }}"
          exit 1
        fi
        
        # Limpiar known_hosts para evitar problemas
        ssh-keygen -f "/root/.ssh/known_hosts" -R "{{ source_server }}" 2>/dev/null || true
        
        # Copiar el archivo usando scp con timeout de 30 segundos
        timeout 30 scp -v -o StrictHostKeyChecking=no \
            -o ConnectTimeout=5 \
            -o UserKnownHostsFile=/dev/null \
            -o LogLevel=ERROR \
            -o PasswordAuthentication=no \
            {{ source_server }}:{{ source_full_path }} {{ dest_full_path }} 2>&1
        
        SCP_EXIT_CODE=$?
        echo "Código de salida SCP: $SCP_EXIT_CODE"
        
        if [ $SCP_EXIT_CODE -eq 0 ]; then
          echo "✅ Archivo copiado exitosamente"
          # Verificar que el archivo existe después de la copia
          if [ -f {{ dest_full_path }} ]; then
            echo "✅ Verificación: archivo existe en destino"
            echo "Tamaño: $(ls -lh {{ dest_full_path }} | awk '{print $5}')"
          else
            echo "❌ ERROR: Archivo no encontrado después de SCP"
            exit 1
          fi
        elif [ $SCP_EXIT_CODE -eq 124 ]; then
          echo "❌ TIMEOUT: SCP tardó más de 30 segundos"
          exit 124
        else
          echo "❌ Error en SCP (código: $SCP_EXIT_CODE)"
          exit $SCP_EXIT_CODE
        fi
        echo "=== FIN COPIA SCP ==="
      args:
        executable: /bin/bash
      register: scp_result
      changed_when: scp_result.rc == 0
      failed_when: scp_result.rc != 0 and scp_result.rc != 124
      async: 45  # Timeout de Ansible de 45 segundos
      poll: 5    # Verificar cada 5 segundos

    - name: "Linux | Mostrar resultado de SCP"
      ansible.builtin.debug:
        msg:
          - "Código SCP: {{ scp_result.rc }}"
          - "Output: {{ scp_result.stdout }}"
          - "Error: {{ scp_result.stderr }}"

    - name: "Linux | Verificar que el archivo se copió correctamente"
      ansible.builtin.stat:
        path: "{{ dest_full_path }}"
      register: file_copied_check

    - name: "Linux | Mostrar información del archivo copiado"
      ansible.builtin.debug:
        msg:
          - "Archivo destino: {{ dest_full_path }}"
          - "Existe: {{ file_copied_check.stat.exists }}"
          - "Tamaño: {{ file_copied_check.stat.size if file_copied_check.stat.exists else 'N/A' }} bytes"
          - "Permisos: {{ file_copied_check.stat.mode if file_copied_check.stat.exists else 'N/A' }}"

    - name: "Linux | Fallar si el archivo no se copió"
      ansible.builtin.fail:
        msg: "El archivo {{ dest_full_path }} no se copió correctamente"
      when: not file_copied_check.stat.exists

    - name: "Linux | DIAGNÓSTICO - Listar contenido del directorio destino"
      ansible.builtin.shell: "ls -la {{ dest_full_path | dirname }} | grep -i {{ pkg.name }} || echo 'No hay archivos de {{ pkg.name }} en {{ dest_full_path | dirname }}'"
      register: dir_listing
      changed_when: false

    - name: "Linux | DIAGNÓSTICO - Mostrar contenido del directorio"
      ansible.builtin.debug:
        msg: "{{ dir_listing.stdout_lines }}"

    - name: "Linux | Ejecutar comando de instalación con diagnóstico"
      ansible.builtin.shell: |
        set -x
        echo "=== INICIANDO INSTALACIÓN ==="
        echo "Archivo a instalar: {{ dest_full_path }}"
        echo "Contenido del directorio:"
        ls -la {{ dest_full_path | dirname }}
        echo ""
        echo "Ejecutando: {{ pkg.commands.install }} {{ dest_full_path }}"
        {{ pkg.commands.install }} {{ dest_full_path }} 2>&1
        INSTALL_EXIT_CODE=$?
        echo "Código de salida: $INSTALL_EXIT_CODE"
        echo "=== FIN INSTALACIÓN ==="
        exit $INSTALL_EXIT_CODE
      args:
        executable: /bin/bash
      register: install_result
      failed_when: false
      changed_when: false

    - name: "Linux | Mostrar resultado de instalación"
      ansible.builtin.debug:
        msg:
          - "Código de salida: {{ install_result.rc }}"
          - "STDOUT: {{ install_result.stdout }}"
          - "STDERR: {{ install_result.stderr }}"

    - name: "Linux | Ejecutar validación post-instalación"
      ansible.builtin.shell: "{{ pkg.commands.post_install_validation }}"
      args:
        executable: /bin/bash
      register: validation_result
      failed_when: false
      changed_when: false

    - name: "Linux | Ejecutar activación (si aplica)"
      ansible.builtin.shell: "{{ pkg.commands.activation }}"
      args:
        executable: /bin/bash
      register: activation_result
      failed_when: false
      changed_when: false
      when: pkg.commands.activation is defined

    - name: "Linux | Iniciar servicio (si aplica)"
      ansible.builtin.shell: "{{ pkg.commands.start }}"
      args:
        executable: /bin/bash
      register: start_result
      failed_when: false
      changed_when: false
      when: pkg.commands.start is defined

    - name: "Linux | Verificar estatus del servicio (si aplica)"
      ansible.builtin.shell: "{{ pkg.commands.status }}"
      args:
        executable: /bin/bash
      register: status_result
      failed_when: false
      changed_when: false
      when: pkg.commands.status is defined

    - name: "Linux | Extraer versión instalada"
      ansible.builtin.set_fact:
        installed_version: >-
          {%- if validation_result.stdout is defined and validation_result.stdout and pkg.version_regex is defined -%}
            {{ validation_result.stdout | regex_search(pkg.version_regex, '\\1') | first | default('') }}
          {%- else -%}
            {{ '' }}
          {%- endif -%}

    - name: "Linux | VERIFICACIÓN MANUAL - Comprobar si {{ pkg.name }} está instalado"
      ansible.builtin.shell: |
        echo "========== VERIFICACIÓN DE INSTALACIÓN: {{ pkg.name }} =========="
        echo "1. Verificando con which:"
        which {{ pkg.name }} 2>/dev/null && echo "✅ {{ pkg.name }} encontrado en $(which {{ pkg.name }})" || echo "❌ {{ pkg.name }} NO encontrado en PATH"
        echo ""
        echo "2. Verificando con rpm:"
        rpm -qa | grep -i {{ pkg.name }} || echo "❌ {{ pkg.name }} no encontrado en RPM database"
        echo ""
        echo "3. Verificando versión (si está instalado):"
        {{ pkg.name }} --version 2>/dev/null || echo "❌ No se pudo obtener versión"
        echo ""
        echo "4. Verificando archivo copiado:"
        ls -la {{ dest_full_path }} 2>/dev/null || echo "❌ Archivo {{ dest_full_path }} no existe"
        echo ""
        echo "5. Verificando dependencias:"
        rpm -qR {{ pkg.name }} 2>/dev/null | head -5 || echo "❌ No se pueden verificar dependencias o paquete no instalado"
        echo ""
        echo "6. Verificando archivos en directorio:"
        ls -la {{ dest_full_path | dirname }} | grep -i {{ pkg.name }} || echo "No hay archivos de {{ pkg.name }} en {{ dest_full_path | dirname }}"
        echo "========== FIN VERIFICACIÓN =========="
      args:
        executable: /bin/bash
      register: verification_check
      changed_when: false
      ignore_errors: true

    - name: "Linux | Mostrar resultado de verificación de {{ pkg.name }}"
      ansible.builtin.debug:
        var: verification_check.stdout_lines

    - name: "Linux | Guardar verificación en archivo de log"
      ansible.builtin.copy:
        content: |
          ========================================
          FECHA: {{ ansible_date_time.iso8601 }}
          HOST: {{ inventory_hostname }}
          PAQUETE: {{ pkg.name }}
          ========================================
          {{ verification_check.stdout }}
          ========================================
          DIAGNÓSTICO ADICIONAL:
          - Archivo destino: {{ dest_full_path }}
          - Existe archivo: {{ file_copied_check.stat.exists if file_copied_check.stat is defined else 'N/A' }}
          - Código instalación: {{ install_result.rc }}
          - Output instalación: {{ install_result.stdout }}
          - Error instalación: {{ install_result.stderr }}
          - Output SCP: {{ scp_result.stdout }}
          - Error SCP: {{ scp_result.stderr }}
          ========================================
        dest: "/tmp/installation_verification_{{ pkg.name }}_{{ ansible_date_time.epoch }}.log"
        mode: '0644'

    - name: "Linux | Anexar resultado de este paquete a la lista del host"
      ansible.builtin.set_fact:
        host_installation_results: "{{ host_installation_results + [ pkg_result ] }}"
      vars:
        pkg_result:
          package_name: "{{ pkg.name }}"
          description: "{{ pkg.description | default('') }}"
          vendor: "{{ pkg.vendor | default('') }}"
          status: "{{ 'success' if validation_result.rc is defined and validation_result.rc == 0 else 'failed' }}"
          install_date: "{{ ansible_date_time.iso8601 }}"
          version_installed: "{{ installed_version | default('') }}"
          copy_output: "{{ scp_result | default({}) }}"
          install_output: "{{ install_result.stdout | default('') }}"
          install_stderr: "{{ install_result.stderr | default('') }}"
          install_rc: "{{ install_result.rc | default('') }}"
          validation_output: "{{ validation_result.stdout | default('') }}"
          activation_output: "{{ activation_result.stdout | default('') }}"
          status_output: "{{ status_result.stdout | default('') }}"
          verification_output: "{{ verification_check.stdout | default('') }}"
          message: ""

  rescue:
    - name: "Linux | Error en el bloque de instalación de {{ pkg.name }}"
      ansible.builtin.set_fact:
        host_installation_results: "{{ host_installation_results + [ error_result ] }}"
      vars:
        error_result:
          package_name: "{{ pkg.name }}"
          description: "{{ pkg.description | default('') }}"
          vendor: "{{ pkg.vendor | default('') }}"
          status: "failed"
          install_date: "{{ ansible_date_time.iso8601 }}"
          version_installed: ""
          copy_output: {}
          install_output: ""
          install_stderr: ""
          install_rc: ""
          validation_output: ""
          activation_output: ""
          status_output: ""
          verification_output: ""
          message: "Error durante la instalación: {{ ansible_failed_result.msg | default('Error desconocido') }}"