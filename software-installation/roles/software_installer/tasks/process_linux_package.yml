---
# roles/software_installer/tasks/process_linux_package.yml

- name: "Linux | Procesando {{ pkg.name }}"
  vars:
    # Ruta del archivo fuente en invd-ts-ansible
    source_full_path: "/software_repo/{{ pkg.src_file }}"
    # Ruta temporal en el servidor destino
    temp_dest_path: "/tmp/{{ pkg.src_file }}"
    dest_full_path: "{{ pkg.dest_path | default('/tmp/') }}{{ pkg.src_file }}"
  block:
    - name: "Linux | Verificar que el archivo existe en invd-ts-ansible"
      ansible.builtin.stat:
        path: "{{ source_full_path }}"
      delegate_to: invd-ts-ansible
      register: file_check
      run_once: true

    - name: "Linux | Detener si el archivo no existe"
      ansible.builtin.fail:
        msg: "El archivo {{ source_full_path }} no existe en invd-ts-ansible"
      when: not file_check.stat.exists

    - name: "Linux | Copiar {{ pkg.src_file }} desde invd-ts-ansible al servidor destino (MEJORADO)"
      ansible.builtin.fetch:
        src: "{{ source_full_path }}"
        dest: "{{ temp_dest_path }}"
        flat: yes
      delegate_to: invd-ts-ansible
      register: fetch_result

    - name: "Linux | Verificar que el archivo se copió correctamente"
      ansible.builtin.stat:
        path: "{{ temp_dest_path }}"
      register: file_copied_check

    - name: "Linux | Mostrar información del archivo copiado"
      ansible.builtin.debug:
        msg:
          - "Archivo copiado a: {{ temp_dest_path }}"
          - "Existe: {{ file_copied_check.stat.exists }}"
          - "Tamaño: {{ file_copied_check.stat.size if file_copied_check.stat.exists else 'N/A' }} bytes"
      when: file_copied_check.stat is defined

    - name: "Linux | Mover el archivo a la ubicación final (si es necesario)"
      ansible.builtin.copy:
        src: "{{ temp_dest_path }}"
        dest: "{{ dest_full_path }}"
        mode: '0644'
        remote_src: yes
      when: pkg.dest_path is defined and pkg.dest_path != '/tmp/'
      register: move_result

    - name: "Linux | Verificar archivo en destino final"
      ansible.builtin.stat:
        path: "{{ dest_full_path }}"
      register: dest_file_check

    - name: "Linux | DIAGNÓSTICO - Listar contenido de /tmp antes de instalación"
      ansible.builtin.shell: "ls -la /tmp/ | grep -i htop || echo 'No hay archivos htop en /tmp'"
      register: tmp_listing_before
      changed_when: false

    - name: "Linux | DIAGNÓSTICO - Mostrar contenido de /tmp"
      ansible.builtin.debug:
        msg: "{{ tmp_listing_before.stdout_lines }}"

    - name: "Linux | Ejecutar comando de instalación con diagnóstico"
      ansible.builtin.shell: |
        set -x  # Modo debug
        echo "=== INICIANDO INSTALACIÓN ==="
        echo "Archivo a instalar: {{ dest_full_path }}"
        echo "Contenido del directorio:"
        ls -la {{ dest_full_path | dirname }}
        echo ""
        echo "Ejecutando: {{ pkg.commands.install }} {{ dest_full_path }}"
        {{ pkg.commands.install }} {{ dest_full_path }} 2>&1
        INSTALL_EXIT_CODE=$?
        echo "Código de salida: $INSTALL_EXIT_CODE"
        echo "=== FIN INSTALACIÓN ==="
        exit $INSTALL_EXIT_CODE
      args:
        executable: /bin/bash
      register: install_result
      failed_when: false
      changed_when: false

    - name: "Linux | Mostrar resultado de instalación"
      ansible.builtin.debug:
        msg:
          - "Código de salida: {{ install_result.rc }}"
          - "STDOUT: {{ install_result.stdout }}"
          - "STDERR: {{ install_result.stderr }}"

    - name: "Linux | Ejecutar validación post-instalación"
      ansible.builtin.shell: "{{ pkg.commands.post_install_validation }}"
      args:
        executable: /bin/bash
      register: validation_result
      failed_when: false
      changed_when: false

    - name: "Linux | Ejecutar activación (si aplica)"
      ansible.builtin.shell: "{{ pkg.commands.activation }}"
      args:
        executable: /bin/bash
      register: activation_result
      failed_when: false
      changed_when: false
      when: pkg.commands.activation is defined

    - name: "Linux | Iniciar servicio (si aplica)"
      ansible.builtin.shell: "{{ pkg.commands.start }}"
      args:
        executable: /bin/bash
      register: start_result
      failed_when: false
      changed_when: false
      when: pkg.commands.start is defined

    - name: "Linux | Verificar estatus del servicio (si aplica)"
      ansible.builtin.shell: "{{ pkg.commands.status }}"
      args:
        executable: /bin/bash
      register: status_result
      failed_when: false
      changed_when: false
      when: pkg.commands.status is defined

    - name: "Linux | Extraer versión instalada (CORREGIDO)"
      ansible.builtin.set_fact:
        installed_version: >-
          {%- if validation_result.stdout is defined and validation_result.stdout and pkg.version_regex is defined -%}
            {{ validation_result.stdout | regex_search(pkg.version_regex, '\\1') | first | default('') }}
          {%- else -%}
            {{ '' }}
          {%- endif -%}

    - name: "Linux | DIAGNÓSTICO - Listar contenido de /tmp después de instalación"
      ansible.builtin.shell: "ls -la /tmp/ | grep -i htop || echo 'No hay archivos htop en /tmp'"
      register: tmp_listing_after
      changed_when: false

    - name: "Linux | Limpiar archivo temporal (solo si está en /tmp y no es destino final)"
      ansible.builtin.file:
        path: "{{ temp_dest_path }}"
        state: absent
      when: temp_dest_path != dest_full_path and temp_dest_path == '/tmp/' + pkg.src_file

    - name: "Linux | VERIFICACIÓN MANUAL - Comprobar si {{ pkg.name }} está instalado"
      ansible.builtin.shell: |
        echo "========== VERIFICACIÓN DE INSTALACIÓN: {{ pkg.name }} =========="
        echo "1. Verificando con which:"
        which {{ pkg.name }} 2>/dev/null && echo "✅ {{ pkg.name }} encontrado en $(which {{ pkg.name }})" || echo "❌ {{ pkg.name }} NO encontrado en PATH"
        echo ""
        echo "2. Verificando con rpm:"
        rpm -qa | grep -i {{ pkg.name }} || echo "❌ {{ pkg.name }} no encontrado en RPM database"
        echo ""
        echo "3. Verificando versión (si está instalado):"
        {{ pkg.name }} --version 2>/dev/null || echo "❌ No se pudo obtener versión"
        echo ""
        echo "4. Verificando archivo copiado:"
        ls -la {{ dest_full_path }} 2>/dev/null || echo "❌ Archivo {{ dest_full_path }} no existe"
        echo ""
        echo "5. Verificando dependencias (opcional):"
        rpm -qR {{ pkg.name }} 2>/dev/null | head -5 || echo "❌ No se pueden verificar dependencias"
        echo ""
        echo "6. Verificando archivos en /tmp:"
        ls -la /tmp/ | grep -i {{ pkg.name }} || echo "No hay archivos de {{ pkg.name }} en /tmp"
        echo "========== FIN VERIFICACIÓN =========="
      args:
        executable: /bin/bash
      register: verification_check
      changed_when: false
      ignore_errors: true

    - name: "Linux | Mostrar resultado de verificación de {{ pkg.name }}"
      ansible.builtin.debug:
        var: verification_check.stdout_lines

    - name: "Linux | Guardar verificación en archivo de log"
      ansible.builtin.copy:
        content: |
          ========================================
          FECHA: {{ ansible_date_time.iso8601 }}
          HOST: {{ inventory_hostname }}
          PAQUETE: {{ pkg.name }}
          ========================================
          {{ verification_check.stdout }}
          ========================================
          DIAGNÓSTICO ADICIONAL:
          - Código instalación: {{ install_result.rc }}
          - Output instalación: {{ install_result.stdout }}
          - Error instalación: {{ install_result.stderr }}
          ========================================
        dest: "/tmp/installation_verification_{{ pkg.name }}_{{ ansible_date_time.epoch }}.log"
        mode: '0644'

    - name: "Linux | Anexar resultado de este paquete a la lista del host"
      ansible.builtin.set_fact:
        host_installation_results: "{{ host_installation_results + [ pkg_result ] }}"
      vars:
        pkg_result:
          package_name: "{{ pkg.name }}"
          description: "{{ pkg.description | default('') }}"
          vendor: "{{ pkg.vendor | default('') }}"
          status: "{{ 'success' if validation_result.rc is defined and validation_result.rc == 0 else 'failed' }}"
          install_date: "{{ ansible_date_time.iso8601 }}"
          version_installed: "{{ installed_version | default('') }}"
          copy_output: "{{ fetch_result | default({}) }}"
          install_output: "{{ install_result.stdout | default('') }}"
          install_stderr: "{{ install_result.stderr | default('') }}"
          install_rc: "{{ install_result.rc | default('') }}"
          validation_output: "{{ validation_result.stdout | default('') }}"
          activation_output: "{{ activation_result.stdout | default('') }}"
          status_output: "{{ status_result.stdout | default('') }}"
          verification_output: "{{ verification_check.stdout | default('') }}"
          message: ""

  rescue:
    - name: "Linux | Error en el bloque de instalación de {{ pkg.name }}"
      ansible.builtin.set_fact:
        host_installation_results: "{{ host_installation_results + [ error_result ] }}"
      vars:
        error_result:
          package_name: "{{ pkg.name }}"
          description: "{{ pkg.description | default('') }}"
          vendor: "{{ pkg.vendor | default('') }}"
          status: "failed"
          install_date: "{{ ansible_date_time.iso8601 }}"
          version_installed: ""
          copy_output: {}
          install_output: ""
          install_stderr: ""
          install_rc: ""
          validation_output: ""
          activation_output: ""
          status_output: ""
          verification_output: ""
          message: "Error durante la instalación: {{ ansible_failed_result.msg | default('Error desconocido') }}"