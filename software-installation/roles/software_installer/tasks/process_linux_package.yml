---
# roles/software_installer/tasks/process_linux_package.yml

- name: "Linux | Inicializar variables"
  ansible.builtin.set_fact:
    install_result:
      rc: "N/A"
      stdout: ""
      stderr: ""
    validation_result:
      rc: "N/A"
      stdout: ""
      stderr: ""

- name: "Linux | Procesando {{ pkg.name }}"
  vars:
    # Ruta del archivo fuente en invd-ts-ansible
    source_full_path: "/software_repo/{{ pkg.src_file }}"
    # Ruta destino en el servidor Linux
    dest_full_path: "{{ pkg.dest_path | default('/tmp/') }}{{ pkg.src_file }}"
    # Ruta temporal en el nodo controlador
    controller_temp_path: "/tmp/ansible_temp_{{ pkg.src_file }}"
  block:
    # ============================================
    # PASO 1: VERIFICACION EN ORIGEN
    # ============================================
    - name: "Linux | Verificar que el archivo existe en invd-ts-ansible"
      ansible.builtin.stat:
        path: "{{ source_full_path }}"
      delegate_to: invd-ts-ansible
      register: file_check
      run_once: true

    - name: "Linux | Detener si el archivo no existe"
      ansible.builtin.fail:
        msg: "El archivo {{ source_full_path }} no existe en invd-ts-ansible"
      when: not file_check.stat.exists

    # ============================================
    # PASO 2: FETCH - TRAER ARCHIVO AL NODO CONTROLADOR
    # ============================================
    - name: "Linux | FETCH - Traer archivo desde invd-ts-ansible al nodo controlador"
      ansible.builtin.fetch:
        src: "{{ source_full_path }}"
        dest: "{{ controller_temp_path }}"
        flat: yes
      delegate_to: invd-ts-ansible
      register: fetch_result
      run_once: true

    - name: "Linux | Verificar que el fetch fue exitoso"
      ansible.builtin.stat:
        path: "{{ controller_temp_path }}"
      delegate_to: localhost
      register: fetch_check
      run_once: true

    - name: "Linux | Mostrar informacion del fetch"
      ansible.builtin.debug:
        msg:
          - "Fetch source: {{ source_full_path }}"
          - "Fetch dest (controller): {{ controller_temp_path }}"
          - "Fetch result: {{ fetch_result }}"
      run_once: true

    - name: "Linux | Detener si el archivo no se copio al controlador"
      ansible.builtin.fail:
        msg: "El archivo {{ controller_temp_path }} no existe en el nodo controlador"
      when: not fetch_check.stat.exists

    # ============================================
    # PASO 3: COPY - COPIAR ARCHIVO DEL CONTROLADOR AL SERVIDOR DESTINO
    # ============================================
    - name: "Linux | Copiar archivo desde nodo controlador al servidor destino"
      ansible.builtin.copy:
        src: "{{ controller_temp_path }}"
        dest: "{{ dest_full_path }}"
        mode: "0644"
      register: copy_result

    - name: "Linux | Verificar que el archivo se copio al destino"
      ansible.builtin.stat:
        path: "{{ dest_full_path }}"
      register: copy_check

    - name: "Linux | Detener si el archivo no se copio al destino"
      ansible.builtin.fail:
        msg: "El archivo {{ dest_full_path }} no existe en el host destino"
      when: not copy_check.stat.exists

    # ============================================
    # PASO 4: VALIDACION DE PAQUETE (BASADA EN NEVRA)
    # ============================================
    - name: "Linux | Obtener lista de paquetes instalados (NEVRA)"
      ansible.builtin.command: rpm -qa --qf '%{NAME}-%{EPOCHNUM}:%{VERSION}-%{RELEASE}.%{ARCH}\n'
      register: rpm_list
      changed_when: false

    - name: "Linux | Verificar si el paquete ya está instalado"
      ansible.builtin.set_fact:
        package_installed: "{{ (rpm_list.stdout_lines | default([])) | select('search', '^' ~ pkg.nevra_regex) | list | length > 0 }}"

    - name: "Linux | Mostrar resultado de verificación de instalación"
      ansible.builtin.debug:
        msg:
          - "Paquete: {{ pkg.name }}"
          - "Regex NEVRA: {{ pkg.nevra_regex }}"
          - "Instalado: {{ package_installed }}"

    # ============================================
    # PASO 5: INSTALACION / ACTUALIZACION
    # ============================================
    - name: "Linux | Instalar paquete (si no está instalado)"
      ansible.builtin.command: "rpm -Uvh --nosignature {{ dest_full_path }}"
      register: install_result
      when: not package_installed

    - name: "Linux | Saltar instalación (ya instalado)"
      ansible.builtin.debug:
        msg: "El paquete {{ pkg.name }} ya está instalado. Se omite instalación."
      when: package_installed

    # ============================================
    # PASO 6: VALIDACION POST-INSTALACION
    # ============================================
    - name: "Linux | Validar post-instalacion (revisar NEVRA en rpm -qa)"
      ansible.builtin.command: rpm -qa --qf '%{NAME}-%{EPOCHNUM}:%{VERSION}-%{RELEASE}.%{ARCH}\n'
      register: rpm_list_post
      changed_when: false

    - name: "Linux | Determinar si el paquete quedó instalado después"
      ansible.builtin.set_fact:
        package_installed_after: "{{ (rpm_list_post.stdout_lines | default([])) | select('search', '^' ~ pkg.nevra_regex) | list | length > 0 }}"

    - name: "Linux | Guardar resultado de validación"
      ansible.builtin.set_fact:
        validation_result:
          rc: "{{ 0 if package_installed_after else 1 }}"
          stdout: >-
            {{
              'OK: paquete presente tras instalación' if package_installed_after
              else 'ERROR: paquete NO aparece tras instalación'
            }}
          stderr: ""

    - name: "Linux | Mostrar validación final"
      ansible.builtin.debug:
        msg:
          - "Paquete: {{ pkg.name }}"
          - "Instalado (después): {{ package_installed_after }}"
          - "Validation rc: {{ validation_result.rc }}"
          - "Validation stdout: {{ validation_result.stdout }}"

    # ============================================
    # PASO 7: LIMPIEZA
    # ============================================
    - name: "Linux | Eliminar archivo copiado en destino (opcional)"
      ansible.builtin.file:
        path: "{{ dest_full_path }}"
        state: absent
      when: (pkg.cleanup_dest | default(false)) | bool

    - name: "Linux | Eliminar archivo temporal en controlador"
      ansible.builtin.file:
        path: "{{ controller_temp_path }}"
        state: absent
      delegate_to: localhost
      run_once: true

    # ============================================
    # PASO 8: LOG
    # ============================================
    - name: "Linux | Guardar verificacion en archivo de log"
      ansible.builtin.copy:
        dest: "{{ report_dir }}/linux_software_install_{{ inventory_hostname }}.log"
        content: |
          ============================================
          Host: {{ inventory_hostname }}
          Paquete: {{ pkg.name }}
          Archivo: {{ pkg.src_file }}
          Fecha: {{ ansible_date_time.iso8601 }}
          --------------------------------------------
          Instalado (antes): {{ package_installed }}
          Codigo instalacion: {{ install_result.rc }}
          Output instalacion: {{ install_result.stdout }}
          Error instalacion: {{ install_result.stderr }}
          --------------------------------------------
          Instalado (después): {{ package_installed_after }}
          Codigo validacion: {{ validation_result.rc }}
          Output validacion: {{ validation_result.stdout }}
          ============================================

  rescue:
    - name: "Linux | Error al procesar {{ pkg.name }}"
      ansible.builtin.debug:
        msg:
          - "Ocurrió un error al procesar el paquete {{ pkg.name }}"
          - "Error: {{ ansible_failed_result | default({}) }}"

    - name: "Linux | Guardar error en log"
      ansible.builtin.copy:
        dest: "{{ report_dir }}/linux_software_install_{{ inventory_hostname }}.log"
        content: |
          ============================================
          Host: {{ inventory_hostname }}
          Paquete: {{ pkg.name }}
          Archivo: {{ pkg.src_file }}
          Fecha: {{ ansible_date_time.iso8601 }}
          --------------------------------------------
          ERROR durante el procesamiento del paquete.
          Detalle:
          {{ ansible_failed_result | default({}) }}
          ============================================

  always:
    - name: "Linux | Fin del procesamiento de {{ pkg.name }}"
      ansible.builtin.debug:
        msg: "Finalizó procesamiento de {{ pkg.name }} en {{ inventory_hostname }}"
